# StateManager Snapshots and Static Data Documentation

This document provides a comprehensive overview of the `StateManager` snapshot system and static data structures, which are core components of the application's state management architecture.

## Overview

The state management system separates **dynamic game state** (snapshots) from **static game structure** (staticData):

- **Snapshots**: Read-only, point-in-time representation of the current game state (what the player has, what's been checked, what's reachable)
- **StaticData**: Fixed game structure that doesn't change during gameplay (all possible locations, items, regions, etc.)

Both are generated by the `StateManager` running in the Web Worker and sent to the main UI thread. This mechanism allows UI components to access game information without directly interacting with the `StateManager` or freezing the UI with complex computations.

---

## State Snapshots

### Overview

A snapshot is generated whenever the game state changes (e.g., a player collects an item, checks a location). The `StateManager` generates a new snapshot and broadcasts it via the `stateManager:snapshotUpdated` event. UI modules listen for these updates and re-render themselves accordingly.

### Snapshot Generation

The snapshot is generated by the `getSnapshot()` method within `frontend/modules/stateManager/core/statePersistence.js:87`. This method gathers data from various parts of the `StateManager` and assembles it into a single, comprehensive object.

### Snapshot Data Structure

The snapshot object contains the following properties. Each property provides a different slice of the current game state.

#### `inventory`

- **Type**: `Object`
- **Description**: A key-value map where keys are item names and values are their counts. This reflects the player's current inventory state.
- **Example**: `{ "Progressive Sword": 2, "Bow": 1, "Hookshot": 1 }`
- **Source**: Copy of `sm.inventory` (canonical format)

#### `flags`

- **Type**: `Array<string>`
- **Description**: An array of strings representing active game-specific state flags. These are often used for tracking story progression or world states that aren't represented by items.
- **Source**: `sm.gameStateModule?.flags || []`

#### `checkedLocations`

- **Type**: `Array<string>`
- **Description**: A list of all location names that the player has marked as "checked" or "visited".
- **Source**: `Array.from(sm.checkedLocations || [])`

#### `regionReachability`

- **Type**: `Object`
- **Description**: A map where keys are region names. The value for each key is a string indicating the region's current accessibility status:
  - `'reachable'`: The player can currently access this region
  - `'unreachable'`: The player cannot currently access this region
- **Example**: `{ "Light World": "reachable", "Dark World": "unreachable" }`
- **Source**: Computed from `sm.knownReachableRegions` and `sm.knownUnreachableRegions`

#### `locationReachability`

- **Type**: `Object`
- **Description**: A map where keys are location names. The value for each key is a string indicating the location's current accessibility status:
  - `'reachable'`: The player can currently access this location
  - `'unreachable'`: The player cannot currently access this location
  - `'checked'`: The location has been checked
- **Example**: `{ "Master Sword Pedestal": "unreachable", "Uncle": "checked" }`
- **Source**: Computed via `sm.isLocationChecked()` and `sm.isLocationAccessible()`

#### `player`

- **Type**: `Object`
- **Description**: Contains information about the current player, including:
  - `name` (string): The player's name (from settings or defaults to `"Player {slot}"`)
  - `slot` (number): The player's slot number in a multi-world game
  - `team` (number): The player's team number
- **Source**: Assembled from `sm.settings.playerName`, `sm.playerSlot`, and `sm.team`

#### `game`

- **Type**: `string`
- **Description**: An identifier for the current game being played, such as `"A Link to the Past"` or `"Adventure"`.
- **Source**: `sm.rules?.game_name || sm.settings?.game || 'Unknown'`

#### `difficultyRequirements`

- **Type**: `Object | undefined`
- **Description**: Contains settings and values related to game difficulty, which might affect item requirements or other logic. Game-specific structure.
- **Source**: `sm.gameStateModule?.difficultyRequirements`

#### `shops`

- **Type**: `Object | undefined`
- **Description**: Data related to the state and contents of in-game shops, if applicable to the user's game. Game-specific structure.
- **Source**: `sm.gameStateModule?.shops`

#### `gameMode`

- **Type**: `string | undefined`
- **Description**: The specific mode of the game being played (e.g., "Archipelago Loops").
- **Source**: `sm.gameStateModule?.gameMode || sm.mode`

#### `events`

- **Type**: `Array<string>`
- **Description**: An array of event names that have occurred in the game. Game-specific.
- **Source**: `sm.gameStateModule?.events || []`

#### `debugMode`

- **Type**: `boolean`
- **Description**: Indicates whether debug mode is enabled for detailed logging.
- **Source**: `sm.debugMode || false`

#### `autoCollectEventsEnabled`

- **Type**: `boolean`
- **Description**: Indicates whether automatic collection of event items is enabled.
- **Source**: `sm.autoCollectEventsEnabled !== false` (defaults to true)

#### `eventLocations`

- **Type**: `Object`
- **Description**: A map of event location names to their location data. Event locations are special locations that trigger events when checked.
- **Source**: Converted from `sm.eventLocations` Map to plain object

#### `startRegions`

- **Type**: `Array<string>`
- **Description**: An array of region names where the player starts the game.
- **Source**: `sm.startRegions || ['Menu']`

---

## Static Data

### Overview

Static data contains the fixed game structure that doesn't change during gameplay. This includes all possible locations, items, regions, their relationships, and metadata. The static data is loaded once when rules are processed and remains constant throughout the session.

### Static Data Generation

Static data is generated by the `getStaticGameData()` method within `frontend/modules/stateManager/core/statePersistence.js:479`. This method extracts structural information from the `StateManager` and packages it for use by UI components and helper functions.

### Static Data Structure

The static data object contains the following properties:

#### `game_name`

- **Type**: `string | undefined`
- **Description**: The name of the game (e.g., "A Link to the Past", "Adventure")
- **Source**: `sm.rules?.game_name`

#### `game_directory`

- **Type**: `string | undefined`
- **Description**: The directory path for the game's files
- **Source**: `sm.rules?.game_directory`

#### `playerId`

- **Type**: `string`
- **Description**: The player slot number as a string
- **Source**: `String(sm.playerSlot)`

#### `locations`

- **Type**: `Map<string, Object>`
- **Description**: A Map where keys are location names and values are location objects containing:
  - `name`: Location name
  - `item`: Item at this location (object with `name` and `player` properties)
  - `region`: Parent region name
  - `access_rule`: Rule determining if location is accessible
  - Other location-specific properties
- **Source**: `sm.locations || new Map()`
- **Note**: Returned as Map (not array) for O(1) lookups

#### `regions`

- **Type**: `Map<string, Object>`
- **Description**: A Map where keys are region names and values are region objects containing:
  - `name`: Region name
  - `exits`: Array of exit objects
  - Other region-specific properties
- **Source**: `sm.regions || new Map()`
- **Note**: Returned as Map (not array) for O(1) lookups

#### `exits`

- **Type**: `Array<Object> | undefined`
- **Description**: Array of all exit objects, each containing:
  - `name`: Exit name
  - `source_region`: Region the exit starts from
  - `target_region`: Region the exit leads to
  - `access_rule`: Rule determining if exit is accessible
- **Source**: `sm.exits`

#### `dungeons`

- **Type**: `Map<string, Object>`
- **Description**: A Map where keys are dungeon names and values are dungeon objects containing dungeon-specific data (bosses, rewards, etc.). Game-specific structure.
- **Source**: `sm.dungeons || new Map()`
- **Note**: Returned as Map (not array) for O(1) lookups

#### `items` / `itemData`

- **Type**: `Object`
- **Description**: Object where keys are item names and values are item definition objects containing:
  - `id`: Item ID number
  - `event`: Boolean indicating if this is an event item
  - `max_count`: Maximum number of this item that can exist
  - Other item-specific properties
- **Source**: `sm.itemData`
- **Note**: Both `items` and `itemData` reference the same object for backwards compatibility

#### `itemsByPlayer`

- **Type**: `Object`
- **Description**: Items indexed by player slot for stateInterface. Format: `{ "{playerSlot}": itemData }`
- **Source**: `{ [String(sm.playerSlot)]: sm.itemData }`

#### `groups` / `groupData`

- **Type**: `Object`
- **Description**: Object where keys are group names and values are arrays of item names belonging to that group
- **Example**: `{ "Swords": ["Fighter Sword", "Master Sword", "Tempered Sword"], "AnyBottle": ["Bottle", "Bottle (Red Potion)", ...] }`
- **Source**: `sm.groupData`
- **Note**: Both `groups` and `groupData` reference the same object for backwards compatibility

#### `item_groups`

- **Type**: `Object`
- **Description**: Item groups indexed by player slot for stateInterface. Format: `{ "{playerSlot}": groupData }`
- **Source**: `{ [String(sm.playerSlot)]: sm.groupData }`

#### `progressionMapping`

- **Type**: `Object | undefined`
- **Description**: Mapping of progressive item base names to their tier sequences
- **Example**: `{ "Progressive Sword": ["Fighter Sword", "Master Sword", "Tempered Sword", "Golden Sword"] }`
- **Source**: `sm.progressionMapping`

#### `itempoolCounts`

- **Type**: `Object | undefined`
- **Description**: Count of each item in the item pool for this game/seed
- **Example**: `{ "Progressive Sword": 4, "Bow": 1, "__max_progressive_bottle": 4 }`
- **Source**: `sm.itempoolCounts`
- **Note**: Special keys starting with `__max_` indicate maximum limits for certain progressive items

#### `startRegions`

- **Type**: `Array<string> | undefined`
- **Description**: Array of region names where the player starts
- **Source**: `sm.startRegions`

#### `mode`

- **Type**: `string | undefined`
- **Description**: Game mode identifier
- **Source**: `sm.mode`

#### `game_info`

- **Type**: `Object | undefined`
- **Description**: Game-specific information and metadata. Structure varies by game.
- **Source**: `sm.gameInfo`

#### `settings`

- **Type**: `Object | undefined`
- **Description**: Complete game settings object from rules.json, containing all configuration for the current game/seed
- **Source**: `sm.rules?.settings`

#### `locationNameToId`

- **Type**: `Object`
- **Description**: Mapping of location names to their numeric IDs for server communication
- **Example**: `{ "Uncle": 1, "Master Sword Pedestal": 2 }`
- **Source**: `sm.locationNameToId`

#### `itemNameToId`

- **Type**: `Object`
- **Description**: Mapping of item names to their numeric IDs for server communication
- **Example**: `{ "Progressive Sword": 1, "Bow": 2 }`
- **Source**: `sm.itemNameToId`

#### `originalLocationOrder`

- **Type**: `Array<string>`
- **Description**: Original ordering of location names as they appeared in the source rules.json
- **Source**: `sm.originalLocationOrder`

#### `originalRegionOrder`

- **Type**: `Array<string>`
- **Description**: Original ordering of region names as they appeared in the source rules.json
- **Source**: `sm.originalRegionOrder`

#### `originalExitOrder`

- **Type**: `Array<string>`
- **Description**: Original ordering of exit names as they appeared in the source rules.json
- **Source**: `sm.originalExitOrder`

#### `eventLocations`

- **Type**: `Object`
- **Description**: Map of event location names to their location data (converted from Map to plain object)
- **Source**: `Object.fromEntries(sm.eventLocations || new Map())`

#### `locationItems`

- **Type**: `Map<string, Object | null>`
- **Description**: A Map where keys are location names and values are item objects (with `name` and `player` properties) or `null` if no item. This is a derived structure built from the locations Map.
- **Source**: Built from `sm.locations` by extracting item information
- **Note**: Kept as Map for performance

---

## Key Differences

| Aspect | Snapshots | StaticData |
|--------|-----------|------------|
| **Purpose** | Current game state | Fixed game structure |
| **Changes** | Updates frequently during gameplay | Loaded once, remains constant |
| **Contains** | What player has, what's checked, what's reachable | All possible items, locations, regions |
| **Example Data** | `inventory: {"Bow": 1}`, `checkedLocations: ["Uncle"]` | `locations: Map(...)`, `itemData: {...}` |
| **Event** | `stateManager:snapshotUpdated` | `stateManager:rulesLoaded` |

---

## Usage in UI Components

UI components typically access both snapshots and static data:

```javascript
// Get latest snapshot and static data
const snapshot = stateManagerProxySingleton.getLatestStateSnapshot();
const staticData = stateManagerProxySingleton.getStaticData();

// Example: Display all locations with their accessibility
for (const [locationName, locationObj] of staticData.locations) {
  const accessibility = snapshot.locationReachability[locationName];
  const isChecked = snapshot.checkedLocations.includes(locationName);

  // Render location with its current status
  renderLocation(locationObj, accessibility, isChecked);
}
```

---

## Technical Notes

- **Maps vs Objects**: Static data uses Maps for collections that need frequent lookups (locations, regions, dungeons) but returns plain objects for data that's rarely accessed directly
- **Immutability**: Snapshots are designed to be immutable; UI components should not modify them
- **Serialization**: Both snapshots and static data are serialized when sent from the worker to the main thread via `postMessage`
- **Performance**: The separation allows expensive reachability computations to happen in the worker without blocking the UI
