# Metamath Proof Step Ordering

This document explains the different proof step ordering schemes used in Metamath and how they're handled in the Archipelago Metamath world implementation.

## Overview

Metamath proofs can be ordered in several different ways, each serving a different purpose. Understanding these orderings helps explain why proof steps might appear in different sequences depending on the tool or display method used.

## Ordering Schemes

### 1. RPN Verification Order (Internal Storage)

This is how proofs are stored internally in Metamath databases and processed by verifiers.

- **Structure**: Uses Reverse Polish Notation (RPN) with a stack-based evaluation
- **Processing**: Steps are executed sequentially, pushing/popping from a stack
- **Purpose**: Optimized for efficient mechanical verification
- **Example**: In the 2+2=4 proof, the conclusion `eqtr4i` might appear first

#### How it works:
```
1. Start with empty stack
2. Push hypotheses onto stack
3. Apply theorems that pop required items and push conclusions
4. End with one item on stack (the proven statement)
```

### 2. Depth-First Traversal Order (metamath-py)

This is what the `metamath-py` library returns when you call `all_steps()` on a proof.

- **Structure**: Pre-order depth-first traversal of the proof tree
- **Processing**: Starts at root (conclusion), then recursively visits dependencies
- **Purpose**: Natural recursive traversal for proof analysis
- **Example order for 2+2=4**:
  1. `eqtr4i` (conclusion)
  2. `oveq2i` (first dependency)
  3. `df-2` (dependency of oveq2i)
  4. `3eqtri` (second dependency)
  5. ... etc

#### Implementation in metamath-py:
```python
def all_steps(self, explored = None):
    if explored == None: explored = set()
    if self.conclusion in explored: return []
    explored.add(self.conclusion)
    steps = [self]
    for dep in self.dependencies.values():
        steps.extend(dep.all_steps(explored))
    return steps
```

### 3. Lemmon-Style Order (Website Display)

This is what appears on the Metamath Proof Explorer website.

- **Structure**: Pedagogically crafted order for human understanding
- **Processing**: Generated by metamath.exe with `/lemmon/renumber` option
- **Purpose**: Makes proofs easier to read and understand
- **Example order for 2+2=4**:
  1. `df-2` (definition of 2)
  2. `oveq2i` (using step 1)
  3. `df-4` (definition of 4)
  4. `df-3` (definition of 3)
  5. `oveq1i` (using step 4)
  6. `2cn` (2 is complex)
  7. `ax-1cn` (1 is complex)
  8. `addassi` (using steps 6,7)
  9. `3eqtri` (using steps 3,5,8)
  10. `eqtr4i` (using steps 2,9) - conclusion

This ordering tells a story: define the numbers, establish basic facts, build up equalities, reach conclusion.

### 4. Topological Sort Order (Our Implementation)

This is what we implemented for the Archipelago Metamath world.

- **Structure**: Dependencies always come before dependents
- **Processing**: Standard topological sort of the dependency graph
- **Purpose**: Ensures logical progression from axioms to conclusion
- **Benefits**:
  - Guarantees all prerequisites are available before each step
  - More intuitive for understanding proof building
  - Consistent algorithmic approach

#### Our implementation:
```python
def topological_sort_proof(ordered_steps, dependencies):
    # Build graph of dependencies
    # Find nodes with no dependencies
    # Process in order, adding nodes whose dependencies are satisfied
    # Return reordered list
```

## Comparison Table

| Ordering | First Steps | Last Steps | Use Case |
|----------|-------------|------------|----------|
| RPN | Conclusion | Base axioms | Verification |
| Depth-First | Conclusion | Leaf dependencies | Tree traversal |
| Lemmon | Definitions | Conclusion | Human reading |
| Topological | Base axioms | Conclusion | Logical building |

## Implementation Notes

### Current Archipelago Implementation

The Archipelago Metamath world uses **topological sort** for these reasons:

1. **Logical Flow**: Ensures dependencies are always proven before statements that need them
2. **Consistency**: Algorithmic approach that works for any proof
3. **Pedagogical Value**: Similar benefits to Lemmon style but programmatically generated

### Region Connection Structure

Our implementation creates region connections that mirror the dependency graph:
- Menu connects to statements with no dependencies
- Each statement region connects to regions that depend on it
- Access rules enforce the full dependency requirements

### Code Location

The topological sort implementation is in `worlds/metamath/Rules.py`:
- `topological_sort_proof()` function performs the reordering
- Called in `parse_proof_from_database()` after extracting dependencies

## Tools and Commands

### metamath.exe Commands

- `show proof xxx` - Shows condensed proof with gaps
- `show proof xxx /all` - Shows all steps including substitutions
- `show proof xxx /lemmon` - Shows Lemmon-style format
- `show proof xxx /lemmon/renumber` - Matches website numbering
- `show proof xxx /renumber` - Renumbers but keeps RPN structure
- `show proof xxx /reverse` - Shows proof in reverse order

### metamath-py Methods

- `verify_proof(db, rule)` - Returns proof tree root and steps dict
- `root_step.all_steps()` - Returns steps in depth-first order
- `root_step.normal_proof()` - Returns RPN proof as tuple of labels
- `root_step.tree_string()` - Shows proof tree with substitutions

## Key Insights

1. **No Single "Correct" Order**: Different orderings serve different purposes
2. **Trade-offs**: Verification efficiency vs. human readability
3. **Website != Internal**: The Metamath website reorders proofs for clarity
4. **Compressed Format**: Proofs are stored compressed and expanded on demand

## References

- [Metamath Book](https://us.metamath.org/downloads/metamath.pdf) - Appendix B describes compressed proof format
- [metamath-exe source](https://github.com/metamath/metamath-exe) - C implementation showing proof processing
- [metamath-py source](https://github.com/tirix/metamath-py) - Python implementation we use
- [Metamath Proof Explorer](https://us.metamath.org/mpeuni/mmset.html) - Website with Lemmon-style display